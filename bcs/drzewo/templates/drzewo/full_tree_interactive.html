{# templates/drzewo/full_tree_interactive.html #}
{% load static %}
<!DOCTYPE html>
<html lang="pl">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Interaktywny Rodowód</title>
        <script src="https://d3js.org/d3.v7.min.js"></script>
        <style>
    body { margin:0; display:flex; height:100vh; background: #ffffff; color:#eee; }
    #sidebar { width:260px; background:#222; padding:12px; box-sizing:border-box; }
    #stage { flex:1; position:relative; }
    svg { width:100%; height:100%; display:block; }
    .node circle { stroke:#222; stroke-width:1px; }
    .node text { font-size:12px; fill:#fff; pointer-events:none; }
    .node.hover circle { stroke:yellow; stroke-width:2px; r:14; }
    .tooltip { position:absolute; pointer-events:none; background:rgba(0,0,0,0.8); color:#fff; padding:6px 8px; border-radius:6px; font-size:13px; display:none; }
        </style>
    </head>
    <body>
        <div id="sidebar">
            <h3>Filtry</h3>
            <form method="get">
                {{ form.as_p }}
                <input type="hidden" name="submitted" value="1">
                <button type="submit">Odśwież</button>
            </form>
            <hr>
            <h3>Kolorowanie</h3>
            <select id="color-mode">
                <option value="none">Brak</option>
                <option value="generation">Pokolenie</option>
                <option value="gender">Płeć</option>
            </select>
            <hr>
            <p>Kliknij w węzeł → otwiera szczegóły. Najedź → podgląd.</p>
        </div>
        <div id="stage">
            <svg id="svg">
            </svg>
            <div id="tooltip" class="tooltip"></div>
        </div>
        <script>
    const svg = d3.select("#svg");
    const width = document.getElementById("stage").clientWidth;
    const height = document.getElementById("stage").clientHeight;
    const g = svg.append("g");

    // zoom & pan
    const zoom = d3.zoom().scaleExtent([0.1, 10]).on("zoom", (event) => {
      g.attr("transform", event.transform);
    });
    svg.call(zoom).call(zoom.transform, d3.zoomIdentity.translate(0,0).scale(1));

    const tooltip = d3.select("#tooltip");

    let nodesData = [], linksData = [];

    function fetchAndRender(params="") {
      fetch(`/drzewo/full_tree_data_graphviz/?${params}`)
        .then(r => r.json())
        .then(data => {
          nodesData = data.nodes;
          linksData = data.links;
          renderGraph();
        });
    }

    function renderGraph(){
      g.selectAll("*").remove();

      // create a map for quick lookup
      const nodeById = new Map(nodesData.map(d => [d.id, d]));

      // links as straight lines between node centers (Graphviz edge splines could be used instead if desired)
      const link = g.selectAll("line.link")
        .data(linksData)
        .enter()
        .append("line")
        .attr("class", "link")
        .attr("stroke", "#666")
        .attr("stroke-width", 1)
        .attr("x1", d => nodeById.get(d.source).x_norm)
        .attr("y1", d => nodeById.get(d.source).y_norm)
        .attr("x2", d => nodeById.get(d.target).x_norm)
        .attr("y2", d => nodeById.get(d.target).y_norm);

      const node = g.selectAll("g.node")
        .data(nodesData)
        .enter()
        .append("g")
        .attr("class", "node")
        .attr("transform", d => `translate(${d.x_norm},${d.y_norm})`)
        .on("click", (_, d) => { if (d.url) window.open(d.url, "_blank"); })
        .on("mouseover", (event, d) => {
          tooltip.style("display", "block").text(d.name);
          d3.select(event.currentTarget).classed("hover", true);
        })
        .on("mousemove", (event) => {
          tooltip.style("left", (event.pageX + 10) + "px")
                 .style("top",  (event.pageY + 10) + "px");
        })
        .on("mouseout", (event) => {
          tooltip.style("display", "none");
          d3.select(event.currentTarget).classed("hover", false);
        });

      node.append("circle")
        .attr("r", 6)
        .attr("fill", d => d.color || "#66aaff")
        .attr("stroke", "#222")
        .attr("stroke-width", 1.2);

      node.append("text")
        .attr("y", -12)
        .attr("text-anchor", "middle")
        .text(d => d.name)
        .style("font-size", "11px");

      // optionally center/fit to view
      fitToView();
    }

    function fitToView(){
      if (!nodesData.length) return;
      const xs = nodesData.map(d => d.x_norm);
      const ys = nodesData.map(d => d.y_norm);
      const minX = Math.min(...xs), maxX = Math.max(...xs);
      const minY = Math.min(...ys), maxY = Math.max(...ys);
      const pad = 100;
      const contentW = (maxX - minX) + pad*2;
      const contentH = (maxY - minY) + pad*2;
      const svgW = document.getElementById("stage").clientWidth;
      const svgH = document.getElementById("stage").clientHeight;
      const scale = Math.min(svgW / contentW, svgH / contentH);
      const tx = -minX + pad;
      const ty = -minY + pad;
      const transform = d3.zoomIdentity.translate((svgW - contentW*scale)/2, (svgH - contentH*scale)/2).scale(scale).translate(tx, ty);
      svg.transition().duration(600).call(zoom.transform, transform);
    }

    // handle color-mode change client-side or by re-fetching with parameter
    document.getElementById("color-mode").addEventListener("change", (e) => {
      const mode = e.target.value;
      if (mode === "none") {
        nodesData.forEach(n => n.color = "#66aaff");
        renderGraph();
        return;
      }
      // For example: for generation we color by y (layer)
      if (mode === "generation") {
        const ys = [...new Set(nodesData.map(n => n.y_norm))].sort((a,b)=>a-b);
        nodesData.forEach(n => {
          const idx = ys.indexOf(n.y_norm);
          // simple palette calculation
          const hue = Math.round(360 * idx / Math.max(1, ys.length-1));
          n.color = `hsl(${hue} 70% 50%)`;
        });
        renderGraph();
      }
      if (mode === "gender") {
        // if backend provided genders in nodes, e.g. n.gender, use it:
        nodesData.forEach(n => {
          if (n.gender === "M") n.color = "#6aa";
          else if (n.gender === "F") n.color = "#a66";
          else n.color = "#888";
        });
        renderGraph();
      }
    });

    // initial load (allow parameter)
    const only_known_parents = (new URLSearchParams(window.location.search)).get("only_known_parents");
    const params = only_known_parents ? `only_known_parents=${only_known_parents}` : "";
    fetchAndRender(params);
        </script>
    </body>
</html>
